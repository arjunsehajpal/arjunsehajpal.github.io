<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Arjun's Blog</title><link>https://arjunsehajpal.github.io/</link><description>Recent content on Arjun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 11 Dec 2022 00:38:16 +0530</lastBuildDate><atom:link href="https://arjunsehajpal.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Conway’s Law: How much influence does it really carry?</title><link>https://arjunsehajpal.github.io/posts/conways-law/</link><pubDate>Sun, 11 Dec 2022 00:38:16 +0530</pubDate><guid>https://arjunsehajpal.github.io/posts/conways-law/</guid><description>Software design is an iterative process. Its longevity depends upon thousands of small design decisions taken every day, and each decision should be in sync with the other. This constant attention to detail is what makes a software system tick. Hence, the quality of software depends hugely on the efficiency of communication between humans building it. This observation became the basis of Conway’s Law.
Paraphrasing Dr. Melvin E. Conway, “Any organization that designs a system, will produce a design whose structure is a copy of the organization’s communication structure.</description></item><item><title>About</title><link>https://arjunsehajpal.github.io/about/</link><pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate><guid>https://arjunsehajpal.github.io/about/</guid><description>Hi! I am Arjun Sehajpal. I ply my trade as a Data Scientist at ZS, working on Personalization Systems where my responsibilities include building end-to-end Machine Learning workflows. Previously, I worked at Pluto7 as a Machine Learning Engineer, where I worked on developing Demand Forecasting and Supply Chain Optimization solutions, which were deployed on Google Cloud.
I have a keen interest in MLOps, time-series forecasting and Causal-ML. I code mostly in Python, but currently I am also learning Go.</description></item><item><title>NFRs for Data Science Products</title><link>https://arjunsehajpal.github.io/posts/data-science-nfrs/</link><pubDate>Sat, 04 Jun 2022 01:25:27 +0530</pubDate><guid>https://arjunsehajpal.github.io/posts/data-science-nfrs/</guid><description>Non-functional requirements (NFRs) are as important as functional requirements. While the system can still work if the NFRs are not met, it may not meet the stakeholders’ expectations. A functional requirement (FR) defines the specific behaviour of a system, whereas an NFR is a criterion to judge the operation of the system. For instance, a system should show a “list of orders” by the user is defined as a functional requirement, and how much time it takes for a page to load and show the first 10 orders is defined as a non-functional requirement.</description></item><item><title>Model Calibration 01: Intuition</title><link>https://arjunsehajpal.github.io/posts/model_calibration/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://arjunsehajpal.github.io/posts/model_calibration/</guid><description>Depending upon the nature of the problem and the functioning of the model, the format in which output is provided can differ from model to model. For instance, in a multiclass classification problem, a decision tree provides a label, which is narrowed down going down the tree, where each node reduces the set of possible outcomes to one. On the contrary, the neural networks provide a vector of continuous values calculated by applying non-linear transformations to the input vector.</description></item><item><title>Why evaluating forecasts is hard?</title><link>https://arjunsehajpal.github.io/posts/forecasting-brier-score/</link><pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate><guid>https://arjunsehajpal.github.io/posts/forecasting-brier-score/</guid><description>Judging forecasts can be insanely hard than they are supposed to be. As time passes, the accuracy of a particular forecast seems obvious, but it is hardly so. The crux of the problem is the property that makes the forecasting different from classical predictions, i.e., time. The presence of temporal components makes it difficult to implement the techniques that we would have otherwise used, for instance, randomized control experiments. When it comes to time-series problems, only an omniscient being can replay a point in time multiple times to judge the effectiveness of the forecast.</description></item><item><title>Contact</title><link>https://arjunsehajpal.github.io/contact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://arjunsehajpal.github.io/contact/</guid><description/></item><item><title>Projects</title><link>https://arjunsehajpal.github.io/projects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://arjunsehajpal.github.io/projects/</guid><description>Nothing to see here&amp;hellip; Move along!</description></item></channel></rss>