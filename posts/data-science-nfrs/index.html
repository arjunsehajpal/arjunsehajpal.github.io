<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=author content="Arjun Sehajpal"><meta name=description content="An primer on non-functional requirements for ML Systems"><meta name=keywords content="blog,data science,machine learning,data engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="NFRs for Data Science Products"><meta name=twitter:description content="An primer on non-functional requirements for ML Systems"><meta property="og:title" content="NFRs for Data Science Products"><meta property="og:description" content="An primer on non-functional requirements for ML Systems"><meta property="og:type" content="article"><meta property="og:url" content="https://arjunsehajpal.com/posts/data-science-nfrs/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-04T01:25:27+05:30"><meta property="article:modified_time" content="2022-06-04T01:25:27+05:30"><title>NFRs for Data Science Products · Arjun's Blog</title><link rel=canonical href=https://arjunsehajpal.com/posts/data-science-nfrs/><link rel=preload href="https://arjunsehajpal.com/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=https://arjunsehajpal.com/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=https://arjunsehajpal.com/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://arjunsehajpal.com/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=https://arjunsehajpal.com/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://arjunsehajpal.com/images/apple-touch-icon.png><meta name=generator content="Hugo 0.112.3"></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://arjunsehajpal.com/>Arjun's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=https://arjunsehajpal.com/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=https://arjunsehajpal.com/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://arjunsehajpal.com/posts/data-science-nfrs/>NFRs for Data Science Products</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-06-04T01:25:27+05:30>June 4, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
10-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=https://arjunsehajpal.com/tags/product-management/>Product-Management</a></span></div></div></header><div><p>Non-functional requirements (NFRs) are as important as functional requirements. While the system can still work if the NFRs are not met, it may not meet the stakeholders’ expectations. A functional requirement (FR) defines the specific behaviour of a system, whereas an NFR is a criterion to judge the operation of the system. For instance, a system should show a “list of orders” by the user is defined as a functional requirement, and how much time it takes for a page to load and show the first 10 orders is defined as a non-functional requirement. Hence, NFRs refer to the general qualities that provide a good user experience.</p><p>The NFRs are the critical quality attributes that influence the system&rsquo;s architectural design. Although NFRs are considered essential and critical for software success, there are no agreed-upon guidelines on when and how the NFRs should be elicited and documented. The literature further reduces when it comes to Machine Learning Systems. This post is a humble attempt to fill that gap.</p><p>In a traditional software system, one can collect and implement numerous functional requirements. The overall purpose of an ML application is much more focused, like, predicting whether a particular account will churn or not. Thus, there are far fewer functional requirements. Because the functional requirements of an ML system are few, the effective satisfaction of NFRs becomes much more critical.</p><div class="notice info"><div class=notice-title><i class="fa fa-exclamation-circle" aria-hidden=true></i>Info</div><div class=notice-content>In practice, ML implementation will be integrated with more standard software as a part of a larger and more complex system, which as a whole, will have numerous NFRs and FRs.</div></div><p>The NFRs for a Machine Learning System can be of two types, one that applies only to the ML component and the other that applies to the whole system. A requirement like interoperability is only applicable to the machine learning model while scalability will be measured by how the whole system reacts to an increase or decrease in the traffic. The following illustration showcases these two types of NFRs:-</p><figure><img src=https://arjunsehajpal.com/blog-img/NFRs-flow-chart.jpg><figcaption><h4>Fig 01 - NFRs for a Machine Learning System</h4></figcaption></figure><p>The following sections looks into the above defined NFRs in detail. While there are many other NFRs, like fairness, I will focus only on the NFRs defined above as these are the ones that I have encountered. I will try to update this list, as my experience grows.</p><h2 id=ml-specific-nfrs>ML Specific NFRs
<a class=heading-link href=#ml-specific-nfrs><i class="fa fa-link" aria-hidden=true></i></a></h2><h3 id=1-data>1. Data
<a class=heading-link href=#1-data><i class="fa fa-link" aria-hidden=true></i></a></h3><p>The data is ingested into an ML system in two ways. Either the data is archived in distributed file systems and/or in databases before being fed to the system. Or a capability is developed to process the infinite flowing stream of high-velocity data. As storage is cheaply available these days, storing batch data is not a challenge anymore. Processing batch data is also easier as compared to streaming data because of its finite nature and readily available compute resources (offered by various cloud providers). On the other hand, processing the incoming stream data in real-time or near real-time is a bit more nuanced than batch data processing, as the data is unbounded and might arrive out of order. We can evaluate our stream data pipelines on the following quality attributes, to check if they are working as per required.</p><h4 id=11-processing-guarantee>1.1. Processing Guarantee
<a class=heading-link href=#11-processing-guarantee><i class="fa fa-link" aria-hidden=true></i></a></h4><p>This NFR refers to the stream system’s capability to offer processing guarantees, i.e., whether every data sample is processed or not? Processing guarantees come in three flavours, exactly once, at most once, and at least once.</p><figure><img src=https://arjunsehajpal.com/blog-img/Processing-Guarantees.jpg><figcaption><h4>Fig 02 - Types of processing guarantees</h4></figcaption></figure><p>While the most desirable guarantee would be exactly once, it does come at an added cost, which translates to latency. This is because it will involve some level of checkpointing to persist state. Hence, will make the system slow. So, it isn’t preferred in every case. Another factor that can play an important role in choice would be how we want our system to react, in case of a failure? As all the modern messaging systems are distributed by nature, a node might crash or go out of memory or any other unforeseen problem arises. How we handle these failures also plays a key role in determining the processing guarantees of a system.</p><h4 id=12-late-and-out-of-order-data>1.2. Late and out-of-order data
<a class=heading-link href=#12-late-and-out-of-order-data><i class="fa fa-link" aria-hidden=true></i></a></h4><p>This NFR refers to the stream system’s capability of processing data that arrive late or in the different order in which it was emitted. A web clickstream could be interrupted if the publisher crashes, which requires the clickstream to be republished or backfilled, leading to data arriving out of order. In order to deal with such a data point, the state of an aggregate must be preserved, so that query can be reprocessed once the data arrives. This is not practical as preserving the state of every aggregate might lead to an out-of-memory error. Hence, some constraints are required to be applied.</p><p>To handle the late and out-of-order data, stream systems employ the concept of windowing. Windowing is a process of slicing the data source along temporal boundaries, and it can be of three types, static, sliding, and session.</p><figure><img src=https://arjunsehajpal.com/blog-img/03-Type-of-Windows.jpg><figcaption><h4>Fig 03 - Type of Windows</h4></figcaption></figure><p>Though the windows break down the infinite streaming data into finite windows that can be processed individually, we still need to make sure whether the data that we have in a window is complete or not. For this, the concept of watermarks is applied. Watermarks are the temporal notions of completeness of the input. Conceptually, it is easier to think of watermarks as a mapping from processing time to event time. It asserts that no more data event time less than, say, T, have been observed. Depending upon the use case, the watermarks can be of two types, perfect watermarks where our knowledge of data is certain, and heuristic watermarks, where we make an educated guess.</p><h4 id=13-flow-control>1.3. Flow Control
<a class=heading-link href=#13-flow-control><i class="fa fa-link" aria-hidden=true></i></a></h4><p>This NFR measures the system&rsquo;s capability to handle the situation where the incoming data stream contains way more records than our system can handle. This could happen due to general system delays, and excessive accumulation of data in the buffer, which can lead to a long message queue, and the system tries to process it all in one go. There are multiple strategies for dealing with this backpressure, and one can read about them <a href=https://quarkus.io/blog/mutiny-back-pressure/>here</a>.</p><h3 id=2-model>2. Model
<a class=heading-link href=#2-model><i class="fa fa-link" aria-hidden=true></i></a></h3><p>The other component of the ML system is the machine learning model itself. Many of the model’s NFRs depends upon the use case itself. There are certain cases where privacy is more important and in some cases, fairness becomes the top priority. In the following sections, we will focus on the three NFRs relating to models, which are fairly common across all the use-cases.</p><h4 id=21-retrainability>2.1. Retrainability
<a class=heading-link href=#21-retrainability><i class="fa fa-link" aria-hidden=true></i></a></h4><p>No matter what type of model is being used, be it a tree-based or a neural network, all models go rogue after a certain time. This is because the data changes. Stock markets ebb and wane, new products are launched and pandemics hit. So, our model must adapt to the changing world.</p><p>To monitor whether our model’s predictive performance is degrading over time, one can oversee how the underlying data distribution is changing. This change in underlying data distribution is referred to as concept drift.</p><p>Apart from monitoring the concept drift, one should also save all the predictions that the model has generated. Measuring the accuracy of a deployed model is an insanely difficult problem. Saving predictions and monitoring the model performance once the ground truths become available can help us in understanding the “real” predictive performance of our model.</p><h4 id=22-interoperability>2.2. Interoperability
<a class=heading-link href=#22-interoperability><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Interoperability refers to the ability of two systems to communicate effectively with each other. This NFR is vital in the applications developed for the industries like banking and healthcare. The idea here is to make disparate systems or data work together for an enhanced user experience. For instance, various scans generate a large volume of data for a single patient, which is vastly different from the data logged by doctors during routine checkups. If these two data sources are impossible to integrate, there is no way one can hope for a fast diagnosis of a critical illness.</p><p>To bridge the gaps created by an incoherent ecosystem, <a href=https://onnx.ai/>ONNX</a> was launched. It allows developers to develop models in their preferred framework, without worrying about implications that can arise while inference. One can convert machine learning models trained in any framework to ONNX using <a href=https://github.com/onnx/onnxmltools>ONNXMLTools</a>.</p><h4 id=23-distribution-and-scalability>2.3. Distribution and Scalability
<a class=heading-link href=#23-distribution-and-scalability><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Certain machine learning use cases, like language translation, question-answering engine, generating images, or playing games require training massive models on enormous datasets. Training these gargantuan models can take a long time and there could be cases where these models might not fit on a single machine. In such cases, the ability to distribute the training to multiple machines and scale the hardware as the need arises can accelerate the training process, and decrease the probability of failure.</p><p>A typical machine learning training pipeline consists of feeding the data into a preprocessing pipeline, which prepares it to be readily consumed by the model. The model does a forward pass, computes the loss, and tinkers with the parameters in order to minimize the loss function.</p><p>To distribute this whole pipeline, we can break the model into small “functional units”, which are independent in nature and can be recomposed to get the result. These distinct functional units can be executed in parallel to speed up the whole training process. The other way could be to do this on decomposition on the data front, where data is divided into small chunks and multiple machines perform the same computations, but on different data chunks.</p><h2 id=system-level-nfrs>System Level NFRs
<a class=heading-link href=#system-level-nfrs><i class="fa fa-link" aria-hidden=true></i></a></h2><h3 id=scalability>Scalability
<a class=heading-link href=#scalability><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Scalability is every developer’s dream problem. It generally answers the question that whether the system can handle a spike in traffic while not causing any damage to the user experience.</p><p>Scalability is a good problem to have as it communicates loud and clear that everything else is going well. But it is also the trickiest NFR. This is because one is never sure when one should begin to accommodate it in the product architecture. Too early and it might turn out to be a YAGNI (you never gonna need it) situation. Too late and things are beyond repair. So, when one should think about it? There’s a cliche that one should start thinking about scalability before a single line of code is written. According to me, this is not pragmatic. At a very early stage, experimentation with new features should be the top priority. Once the product is stable and one can start making provisions for this NFR. Also, it is very crucial to not take too much technical debt along the way. Following “good” code practices like TDD, uniform code standards, etc. can be really helpful here.</p><p>While designing a scalable solution, one can keep the following pointers in mind:-</p><ul><li>Use caching extensively as caching imparts a sense of a highly scalable solution and gives better output in high-demand situations, without wasting computing resources. Based on the situation, one can implement a browser cache or database cache.</li><li>Use Content Delivery Networks (CDN) because they make applications scale faster without any code-level changes.</li><li>Use load balancer and enable auto-scaling. With the advent of the cloud, enabling these services has never been easier.</li><li>Use messaging mechanism of any type of async operations.</li></ul><h3 id=performance>Performance
<a class=heading-link href=#performance><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Often confused with scalability, this NFR indicates the responsiveness of a system to execute any action within a given interval of time. It deals with the properties like speed, throughput, and responsiveness. To test the performance of the system, one can track metrics like average response time, request rates, and error rates to get a holistic view of how the system is performing.</p><h3 id=flexibility-and-technology-agnosticism>Flexibility and Technology agnosticism
<a class=heading-link href=#flexibility-and-technology-agnosticism><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Flexibility or extensibility measures the ability of a system to extend its functionality against the level of effort required to implement the extension. One should avoid vendor lock-ins and keep their system technologically agnostic in order to increase its extensibility coefficient.</p><h3 id=observability-or-monitoring>Observability or Monitoring
<a class=heading-link href=#observability-or-monitoring><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Observability is the measure of how well the internal states of a system can be inferred from the knowledge of its external output. High-quality sleep and observability are highly correlated. Implementing observability lets you sleep peacefully at night. Moreover, it helps in tackling bugs faster as it provides us the information to track where they are coming from.</p><h3 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa fa-link" aria-hidden=true></i></a></h3><p>In software engineering, there are numerous other NFRs that differ from use-case to use-case. The challenge is not only to identify the right NFRs for your product but also to identify the order in which they are to be implemented. There is no manual for this and this is where experience plays a huge role.</p></div><footer></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2023
Arjun Sehajpal
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=https://arjunsehajpal.com/js/coder.min.9cf2dbf9b6989ef8eae941ffb4231c26d1dc026bca38f1d19fdba50177d8a9ac.js integrity="sha256-nPLb+baYnvjq6UH/tCMcJtHcAmvKOPHRn9ulAXfYqaw="></script></body></html>